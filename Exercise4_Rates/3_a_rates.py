# -*- coding: utf-8 -*-
"""3 a. Rates

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KP0H4W9MNnwbGRXhfAIacp5GEV-2O0PS

write python code to plot us treasury yield curve. show the curve dyamically changing over the last month
"""

# US Treasury Yield Curve — Animated Last-Month Slider (fixed cutoff comparison)
# Requirements: pip install pandas pandas_datareader plotly

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from pandas_datareader import data as web
import plotly.graph_objects as go

FRED_SERIES = {
    "1M": "DGS1MO", "3M": "DGS3MO", "6M": "DGS6MO", "1Y": "DGS1",
    "2Y": "DGS2", "3Y": "DGS3", "5Y": "DGS5", "7Y": "DGS7",
    "10Y": "DGS10", "20Y": "DGS20", "30Y": "DGS30",
}
MATURITY_YEARS = {
    "1M": 1/12, "3M": 3/12, "6M": 6/12, "1Y": 1, "2Y": 2, "3Y": 3,
    "5Y": 5, "7Y": 7, "10Y": 10, "20Y": 20, "30Y": 30
}

# Use pandas Timestamps throughout (avoid mixing with .date())
end_date = pd.Timestamp.today().normalize()
start_date = end_date - pd.Timedelta(days=45)

dfs = []
for label, fred_id in FRED_SERIES.items():
    s = web.DataReader(fred_id, "fred", start_date, end_date)
    s.rename(columns={fred_id: label}, inplace=True)
    dfs.append(s)

df = pd.concat(dfs, axis=1)

# Ensure index is DatetimeIndex
df.index = pd.to_datetime(df.index)

# Forward-fill to cover weekends/holidays; then trim to last ~31 days
df = df.ffill()
cutoff = end_date - pd.Timedelta(days=31)     # Timestamp (matches index dtype)
df_last_month = df.loc[df.index >= cutoff].dropna(how="all")

ordered_cols = sorted(df_last_month.columns, key=lambda k: MATURITY_YEARS[k])
df_last_month = df_last_month[ordered_cols]

x_vals = [MATURITY_YEARS[c] for c in ordered_cols]
dates = df_last_month.index

frames = []
for d in dates:
    y_vals = df_last_month.loc[d].astype(float).values
    frames.append(
        go.Frame(
            name=d.strftime("%Y-%m-%d"),
            data=[go.Scatter(
                x=x_vals, y=y_vals, mode="lines+markers",
                hovertemplate="<b>%{x:.2f}y</b><br>Yield: %{y:.2f}%<extra></extra>"
            )],
            layout=go.Layout(title_text=f"U.S. Treasury Yield Curve — {d.strftime('%Y-%m-%d')}")
        )
    )

latest_date = dates[-1]
latest_y = df_last_month.loc[latest_date].astype(float).values

fig = go.Figure(
    data=[go.Scatter(
        x=x_vals, y=latest_y, mode="lines+markers",
        hovertemplate="<b>%{x:.2f}y</b><br>Yield: %{y:.2f}%<extra></extra>"
    )],
    layout=go.Layout(
        title=f"U.S. Treasury Yield Curve — {latest_date.strftime('%Y-%m-%d')}",
        xaxis=dict(title="Maturity (years)", tickmode="array",
                   tickvals=[1/12, 0.25, 0.5, 1, 2, 3, 5, 7, 10, 20, 30],
                   ticktext=["1M", "3M", "6M", "1Y", "2Y", "3Y", "5Y", "7Y", "10Y", "20Y", "30Y"]),
        yaxis=dict(title="Yield (%)"),
        updatemenus=[dict(
            type="buttons", showactive=False, x=1, y=1.15, xanchor="right",
            buttons=[
                dict(label="Play", method="animate",
                     args=[None, {"frame": {"duration": 150, "redraw": True},
                                  "fromcurrent": True, "transition": {"duration": 0}}]),
                dict(label="Pause", method="animate",
                     args=[[None], {"frame": {"duration": 0, "redraw": False},
                                    "mode": "immediate", "transition": {"duration": 0}}]),
            ]
        )],
        sliders=[{
            "x": 0.05, "len": 0.9, "xanchor": "left",
            "y": -0.08, "yanchor": "top",
            "pad": {"b": 10, "t": 10},
            "currentvalue": {"visible": True, "prefix": "Date: ", "font": {"size": 14}},
            "steps": [
                {"args": [[fr.name],
                          {"frame": {"duration": 0, "redraw": True},
                           "mode": "immediate", "transition": {"duration": 0}}],
                 "label": fr.name, "method": "animate"}
                for fr in frames
            ]
        }]
    ),
    frames=frames
)

# Optional reference: first day curve (dotted)
first_y = df_last_month.iloc[0].astype(float).values
fig.add_trace(go.Scatter(
    x=x_vals, y=first_y, mode="lines", name=f"First day ({dates[0].strftime('%Y-%m-%d')})",
    line=dict(dash="dot"), hoverinfo="skip"
))

fig.update_layout(legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="left", x=0))
fig.show()

"""write code to plot 10 year treasury using fred api. use an arma 1,1 model to predict rates for the next day. calculate probability of success in predicting next days rates based on past data. when success probability is more than 80%, enter trade. check threshold of 80% every day. exit when probability of success of predicting next days rate falls below 80%. calculate sharpe ratio and average annual return."""

# 10Y Treasury ARMAX(1,1) with 2Y as exogenous, confidence-gated trading
# ----------------------------------------------------------------------
# What this does
# - Fetches DGS10 (10Y) and DGS2 (2Y) from FRED using fredapi (API key required)
# - Fits ARMAX(1,1) on 10Y LEVELS with LAGGED 2Y as exogenous (to avoid look-ahead)
# - Produces 1-step-ahead forecasts for 10Y (next day level)
# - Computes rolling directional "probability of success" (hit rate) from past data
# - Enters duration trade when hit rate >= 51%, exits when it falls below 51% (checked daily)
# - Calculates Sharpe ratio (annualized) and average annual return
# - Plots: 10Y level, forecast vs actual Δy (bps), rolling probability & position, cumulative PnL
#
# Requirements
#   pip install fredapi pandas statsmodels matplotlib
#   export FRED_API_KEY=YOUR_KEY   (or paste into FRED_API_KEY variable below)

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from fredapi import Fred
from statsmodels.tsa.arima.model import ARIMA
import warnings
warnings.filterwarnings("ignore")

# ----------------------- User parameters -----------------------
FRED_API_KEY     = os.getenv("FRED_API_KEY", "6f5ab36d76b8f452b7ebc118f0156bf1")  # paste key here if you prefer: "xxxxxxxxxxxxxxxx"
SERIES_10Y       = "DGS10"
SERIES_2Y        = "DGS2"
LOOKBACK_YEARS   = 8           # data history to pull
ARMA_ORDER       = (1, 0, 1)   # ARMAX(1,1) via ARIMA(p=1,d=0,q=1, exog)
MIN_TRAIN_DAYS   = 252         # start evaluation after ~1Y
HIT_WINDOW       = 60          # rolling window (days) to estimate success probability
ENTER_THRESH     = 0.51        # enter/hold if prob >= 51%
EXIT_THRESH      = 0.51        # flat if prob < 51% (daily gating)
NOTIONAL         = 1_000_000.0
DV01_PER_BP      = 900.0       # $ per 1bp for $1mm 10Y exposure
ANNUALIZATION    = 252

# ----------------------- 1) Fetch data from FRED -----------------------
if not FRED_API_KEY:
    raise ValueError("FRED_API_KEY not set. Set env var FRED_API_KEY or paste into FRED_API_KEY variable.")

fred = Fred(api_key=FRED_API_KEY)
start_date = (datetime.today() - timedelta(days=LOOKBACK_YEARS*365)).date()

ten = fred.get_series(SERIES_10Y, observation_start=start_date).to_frame("Y10").dropna()
two = fred.get_series(SERIES_2Y,  observation_start=start_date).to_frame("Y2").dropna()

# Align to business days, forward-fill holidays
ten.index = pd.to_datetime(ten.index)
two.index = pd.to_datetime(two.index)
ten = ten.asfreq("B").ffill()
two = two.asfreq("B").ffill()

df = ten.join(two, how="inner").dropna()

# ----------------------- 2) Prepare endogenous & exogenous -----------------------
# Endogenous: 10Y level (percent)
y = df["Y10"].astype(float)

# Exogenous: LAGGED 2Y level (to avoid look-ahead bias)
# We want to forecast y_t using info up to t-1, so we pass X_t = Y2_{t-1}
X = df["Y2"].shift(1).rename("Y2_lag1")
data = pd.concat([y, X], axis=1).dropna()

# Align series post-dropna
y = data["Y10"]
X = data["Y2_lag1"]

# ----------------------- 3) Fit ARMAX(1,1) with exogenous -----------------------
# We fit on full available sample; then generate 1-step ahead predictions for evaluation window.
model = ARIMA(y, order=ARMA_ORDER, exog=X)
res   = model.fit(method_kwargs={"warn_convergence": False})

# 1-step ahead predictions (dynamic=False gives static 1-step)
start_ix = y.index[MIN_TRAIN_DAYS]
pred_obj = res.get_prediction(start=start_ix, end=y.index[-1], dynamic=False, exog=X.loc[start_ix:])
y_pred   = pred_obj.predicted_mean.rename("Y10_pred")

# ----------------------- 4) Build changes, success metric -----------------------
# Real next-day level and predicted/real changes relative to yesterday's level
y_tm1     = y.shift(1).reindex(y_pred.index)     # Y10_{t-1}
y_t_real  = y.reindex(y_pred.index)              # Y10_t (realized)
dy_pred   = (y_pred - y_tm1).rename("PredDy")    # predicted Δy_t (pct points)
dy_real   = (y_t_real - y_tm1).rename("RealDy")  # realized Δy_t (pct points)

# Directional success indicator (use 0.5 when either side has zero change)
sign_pred = np.sign(dy_pred)
sign_real = np.sign(dy_real)
hit = (sign_pred * sign_real > 0).astype(float)
hit[(sign_pred == 0) | (sign_real == 0)] = 0.5

# Rolling probability of success based only on PAST info (up to t-1)
prob_success = hit.shift(1).rolling(HIT_WINDOW, min_periods=HIT_WINDOW//2).mean().rename("ProbSuccess")

# ----------------------- 5) Daily confidence-gated trading -----------------------
# Signal direction (based on predicted change): long duration if Δy_pred < 0, else short
direction = np.where(dy_pred < 0, 1, -1)

# Gate by probability threshold: in position if prob >= 51%, else flat
position = np.where(prob_success >= ENTER_THRESH, direction, 0).astype(int)

# ----------------------- 6) PnL, Sharpe, Average Annual Return -----------------------
# Realized change in bps for DV01 math
dy_real_bps = (dy_real * 100.0).rename("RealDy_bps")

# Daily PnL: position * (-DV01) * Δy_real(bps)
daily_pnl = position * (-DV01_PER_BP) * dy_real_bps.values
daily_pnl = pd.Series(daily_pnl, index=dy_real_bps.index, name="DailyPnL$")

bt = pd.DataFrame({
    "Y10(%)":       y_t_real.values,
    "Y2_lag1(%)":   X.reindex(y_pred.index).values,
    "PredDy(%)":    dy_pred.values,
    "RealDy(%)":    dy_real.values,
    "ProbSuccess":  prob_success.values,
    "Position":     position,
    "DailyPnL$":    daily_pnl.values
}, index=y_pred.index)
bt["CumPnL$"] = bt["DailyPnL$"].cumsum()

def sharpe_ratio(pnl, periods_per_year=ANNUALIZATION):
    rets = pnl / NOTIONAL
    mu   = np.nanmean(rets) * periods_per_year
    sd   = np.nanstd(rets, ddof=1) * np.sqrt(periods_per_year)
    return np.nan if sd == 0 else mu / sd

daily_ret = bt["DailyPnL$"] / NOTIONAL
avg_annual_return = float(daily_ret.mean() * ANNUALIZATION)
sr = float(sharpe_ratio(bt["DailyPnL$"]))

print("\n=== Performance Summary (ARMAX with 2Y lag) ===")
print(f"Sample: {df.index.min().date()} → {df.index.max().date()}")
print(f"Obs (levels): {len(df):,} | Backtest days: {len(bt):,}")
print(f"Hit-rate window: {HIT_WINDOW}d | Enter/Exit threshold: {ENTER_THRESH:.0%}")
print(f"Days in position: {(bt['Position']!=0).sum():,}")
print(f"Total PnL ($): {bt['CumPnL$'].iloc[-1]:,.0f}")
print(f"Average annual return: {avg_annual_return:.2%}")
print(f"Sharpe ratio (annualized): {sr:.2f}\n")

# ----------------------- 7) Plots -----------------------
# 10Y Level
plt.figure(figsize=(10,4))
plt.plot(df.index, df["Y10"].values, label="10Y Yield (%)")
plt.title("10-Year Treasury Yield (DGS10)")
plt.xlabel("Date"); plt.ylabel("Yield (%)")
plt.tight_layout(); plt.show()

# Forecast vs actual Δy (bps), recent ~6 months
last_n = min(126, len(bt))
if last_n > 5:
    sub = bt.index[-last_n:]
    plt.figure(figsize=(10,4))
    plt.plot(sub, (bt.loc[sub, "RealDy(%)"]*100).values, label="Actual Δy (bps)")
    plt.plot(sub, (bt.loc[sub, "PredDy(%)"]*100).values, label="Forecast Δy (bps)")
    plt.title("Forecast vs. Actual — 10Y Daily Change (bps)")
    plt.xlabel("Date"); plt.ylabel("Δy (bps)")
    plt.legend(); plt.tight_layout(); plt.show()

# Rolling probability & position (recent window)
if last_n > 5:
    sub = bt.index[-last_n:]
    fig, ax1 = plt.subplots(figsize=(10,4))
    ax1.plot(sub, bt.loc[sub, "ProbSuccess"], label="ProbSuccess")
    ax1.axhline(ENTER_THRESH, linestyle="--")
    ax1.set_ylabel("Prob. of success")
    ax1.set_xlabel("Date")
    ax2 = ax1.twinx()
    ax2.step(sub, bt.loc[sub, "Position"], where="post", label="Position")
    ax2.set_ylabel("Position (+1 long, 0 flat, -1 short)")
    plt.title("Rolling Success Probability & Position (recent)")
    fig.tight_layout(); plt.show()

# Cumulative PnL
plt.figure(figsize=(10,4))
plt.plot(bt.index, bt["CumPnL$"].values, label="Cumulative PnL ($)")
plt.title("Cumulative PnL — Confidence-Gated Strategy ($1,000,000 notional)")
plt.xlabel("Date"); plt.ylabel("PnL ($)")
plt.tight_layout(); plt.show()